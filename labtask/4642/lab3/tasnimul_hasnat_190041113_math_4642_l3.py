# -*- coding: utf-8 -*-
"""Tasnimul Hasnat 190041113 - Math_4642_L3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WqDpbkG0L7ojAYh3jCYjYH3-Hhlkqwbd

# **Lab 3 : Newton's Divided Difference Interpolation**<br>

Interpolation is the process of estimating unknown data that lies within the range of some known data. The **Newton's Divided Difference Interpolation** is one of the methods of performing this task. In order to interpolate unknown data, one needs to define a model that would fit the known data and based on that model, one would obtain the unknown data. This model would basically be a function that tries to satisfy the known data points. There can be various types of functions that may satisfy the same given data points, but for interpolation, we usually choose **polynomials** as interpolating functions due to the fact that polynomials are generalized and are very easy to evaluate, differentiate and integrate.

In today's lab, we will be implementing the Newton's Divided Difference Interpolation in python. To test our implementation, we will be using the same data that we used during our class lectures. Run the following cell to load the known data points:
"""

t = [0, 10, 15, 20, 22.5, 30]
v = [0, 227.04, 362.78, 517.35, 602.97, 901.67]

"""##Task 1
Design a utility function that will be called in the Newton's Divided Difference function. The purpose of this function will be to find the n+1 closest points to the unknown value t_new where we want to interpolate the data, where n is the order of the interpolating polynomial. The function to be implemented is as follows:
"""

def NearestPoints(t, v, n, t_new):
    t_nearest = sorted(t, key=lambda x: abs(x - t_new))[:n+1]
    v_nearest = [v[t.index(x)] for x in t_nearest]
    return t_nearest, v_nearest  

# def NearestPoints(t, v, n, t_new):
#   #Write your implementation here
#   id = []
  
#   for idx, val in enumerate(t):
#     td = abs(val - t_new)
#     id.append((td, idx))

#   id = sorted(id)

#   t_nearest, v_nearest = [], []

#   for (val, idx) in id:
#     t_nearest.append(t[idx])
#     v_nearest.append(v[idx])

#   return (t_nearest[: n + 1], v_nearest[: n + 1])

"""The above function is supposed to return two vectors, say t_nearest and v_nearest consisting of n+1 elements each. For testing the working of the function, we can print the data and see what we are getting. Run the following cell to check this:"""

n = 1
t_new = 16

t_nearest, v_nearest = NearestPoints(t, v, n, t_new)
print(t_nearest)
print(v_nearest)

"""##Task 2
Now your task is to design a generalized function that takes the given data as parameters as well as the order (n) of the polynomial and uses the Newton's Divided Difference Polynomial to interpolate the uknown data at t_new. The following cell contains the function to be implemented:
"""

def f(t, v, t_nearest, v_nearest, n, x_ed, x_st):
  if x_ed == x_st:
    return v_nearest[x_ed]
  else:
    numerator = f(t, v, t_nearest, v_nearest, n, x_ed, x_st + 1) - f(t, v, t_nearest, v_nearest, n, x_ed - 1, x_st)
    denominator = t_nearest[x_ed] - t_nearest[x_st]
    return numerator / denominator

def NDD(t, v, n, t_new):
  #Write your implementation here
  
  t_nearest, v_nearest = NearestPoints(t, v, n, t_new)
  
  ret = v_nearest[0]

  mult = [1, t_new - t_nearest[0]]
  for i in range(2, n):
    mult.append(mult[-1] * (t_new - t_nearest[i]))

  for i in range(1, n):

    ret += f(t, v, t_nearest, v_nearest, n, i, 0) * mult[i]

  return ret

print(NDD(t, v, 5, 16))

"""Note that the above function will at first need to find a number of closest points to the unknown data (t_new), and this number will vary depending on the order (n) of the polynomial that we want to use as the interpolating function. So you will have to call the function you implemented in Task 1 inside this function.

##Task 3
Now, test the function using different order of polynomials, setting n = 1, 2, 3 and so on and print the absolute relative approximate error at each step. Also store the time needed for executing the NDD function for the different orders of the polynomial. Finally, generate a plot of **order vs error** and **order vs time** curves in the same graph.
"""

#Write your code here for finding the relative approximate errors and time elapsed for different orders of the polynomial

import time
import matplotlib.pyplot as plt
true_value = NDD(t, v, 1, t_new)

orders = []
errors = []
times = []

for n in range(1, len(t)):
    start = time.time()
    result = NDD(t, v, n, t_new)
    # print(result)
    end = time.time()
    error = abs((result - true_value) / true_value)
    true_value=result
    orders.append(n)
    errors.append(error)
    times.append(end - start)

tt = [t*1e3 for t in times]
print(tt)

print(orders,errors)

plt.plot(orders[1:], errors[1:], label='Error')
plt.plot(orders, tt, label='Time')

plt.legend()
plt.xlabel('Order of Polynomial')
plt.ylabel('Value')
plt.show()