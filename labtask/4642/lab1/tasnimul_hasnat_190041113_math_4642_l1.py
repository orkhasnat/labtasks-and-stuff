# -*- coding: utf-8 -*-
"""Tasnimul Hasnat 190041113 - Math_4642_L1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dOD_e8_2sJiOCCeyVwbrSbESGjMLdecP

# **Lab 1 : Bisection Method**<br>

The bisection method (also known as the binary search method) is a method of finding roots of a non-linear function. The assumption here is that the function is real continuous, otherwise the bisection method will not work. It is based on the **Intermediate Value Theorem** which states that if f(x) is a real continuous function, and if f(x<sub>l</sub>)f(x<sub>u</sub>)\< 0 then there must be a root between x<sub>l</sub> and x<sub>u</sub>.

In today's lab, we will be implementing the bisection method in python. We will be considering the function f(x) as an array of coefficients, for instance if we want to have f(x) = x<sup>3</sup>-2x<sup>2</sup>+4, then in python we will create an array as follows:
"""

import numpy as np

f = np.array([1,-2,0,4])

print(f)

"""Next, you will need to create a user-defined function as follows

```
bisection_method(f, xl, xu, epsilon)
```
This function will return the root of the equation represented by the array f and in case it does not reach the root exactly then it will return the close enough value to the root that has an absolute relative approximate error of at most epsilon (%).

In python, functions are defined as follows
"""

#Execute this cell to test how the function works

def func(a,b):
  result = a + b
  return result

print(func(1,2))

"""Note that in python, we do not need to specify the data type for parameters nor any return type for the function as these are implicitly determined. Also, note the colon (:) after the function signature. Indentation matters in python, since the consecutive codes having same indentation will be considered as a single block.

##Task 1
Implement the function for bisection method following the requirements set earlier. Write a script after the function to call it and test whether it is working correctly.
"""

#Complete the following function
import numpy as np
import matplotlib.pyplot as plt


def sign(x):
  return -1 if x<0 else 0 if x==0 else 1
def eval_equ(f,x):
  sum=0
  y=1
  for i in f[::-1]:
    sum+=i*y
    y*=x
  return sum

def bisection_method(f, xl, xu, epsilon):
  #write your implementation here
  global count,errs
  count=0
  xm_old=0
  errs=[]
  while True:
    count+=1
    xm = (xl + xu) / 2
    err=abs((xm-xm_old)/(xm+0.0000001))
    # err=np.array(err)
    # errs.append(err)
    # np.append(errs,err)
    errs.append(err)
    # print(errs)
    xm_old=xm
    f_midpoint = eval_equ(f, xm)
    if abs(f_midpoint) < epsilon:
      return xm
    elif sign(f_midpoint) == sign(eval_equ(f, xl)):
      xl = xm
    else:
      xu = xm


#Write a driver code here for calling the function and testing it
# count=0
f1= np.array([1,-2,0,4])
f2=np.array([1,-2,-3])
# print(eval_equ(f1,-1))
# print(bisection_method(f1,-3,3,0.01))
print(bisection_method(f2,2,6,0.01))

iters=np.arange(0,count)
print(iters,errs)
plt.plot(iters, errs)
plt.title("Iterations vs values plot")
plt.xlabel("Iteration")
plt.ylabel("Relative Error")
plt.show()

"""We can plot graphs in python using the matplotlib library. An example of plotting graphs is shown here"""

import numpy as np
import matplotlib.pyplot as plt

iters = np.arange(0, 5) #start=0, stop=5, and since no step is given, so default step=1
vals = np.arange(100, 200, 20) #start=100, stop=200, step=20

plt.plot(iters, vals)
plt.title("Iterations vs values plot")
plt.xlabel("Iteration")
plt.ylabel("Value")
plt.show()

"""## Task 2
Generate a plot of **iteration vs relative approx error (%)** for the bisection method function you implemented earlier.
"""