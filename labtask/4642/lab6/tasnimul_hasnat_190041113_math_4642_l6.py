# -*- coding: utf-8 -*-
"""Tasnimul Hasnat 190041113 - Math_4642_L6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aJZulDY5SnU_8A2gbYL45nubk1mMIt0N

# **Lab 6 : Integration**<br>

Integration is the process of measuring the area under a function. This area actually corresponds to the anti-derivative of the function. For instance, a velocity function $v(t)$ can be obtained as a derivative of a distance function $S(t)$. Inversely, the integration of the velocity function $v(t)$ over a certain time period can give us the distance traveled over that time period. Performing integration analytically is a complex procedure, involving a lot of rules. Computers and calculators perform integration using some sort of numerical method, such as the **Simpson's 1/3 rule** and **Simpson's 3/8 rule**.

In today's lab, we will be implementing a mixed version of **Simpson's 1/3 rule** and **Simpson's 3/8 rule** of integration in python. The **Simpson's 1/3 rule** uses a minimum of 2 segments and **Simpson's 3/8 rule** uses a minimum of 3 segments to divide the entire range of the interval of integration, but we can also define a multiple-segment version of this rule that divides the interval into n equal segments, where n is a multiple of 2 and 3 respectively. Suppose we wish to use the n-segment mixed Simpson's 1/3 and Simpson's 3/8 rule to find the distance covered by a rocket from time $t = 8$ to $t = 30$. The velocity function of the rocket is given as $v(t) = 2000ln[ \frac{140000}{140000-2100t} ] - 9.8t$

##Task 1
Implement a function that takes time as an argument and returns the velocity based on the given velocity function. Then, complete the following MultiSimpson13() and MultiSimpson38() function that takes number of segments n and the time interval (tmin, tmax) as arguments and returns the distance covered within this interval. Your function should also check for the validity of the number of segments.
"""

import math
import numpy as np
t1=8
t2=30
n=10

def velocity(t):
    return 2000 * math.log(140000/(140000 - 2100*t)) - 9.8*t

def MultiSimpson13(n, tmin, tmax):
    h = (tmax - tmin) / n
    t = [tmin + i * h for i in range(n+1)]
    v = [velocity(ti) for ti in t]
    sum1 = sum(v[i] for i in range(1, n, 2))
    sum2 = sum(v[i] for i in range(2, n-1, 2))
    integral = (tmax - tmin) / (3 * n) * (v[0] + 4 * sum1 + 2 * sum2 + v[n])
    return integral



def MultiSimpson38(n, tmin, tmax):
    h = (tmax - tmin) / n
    t = [tmin + i * h for i in range(n+1)]
    v = [velocity(ti) for ti in t]
    sum1 = sum(v[i] for i in range(1, n, 3))
    sum2 = sum(v[i] for i in range(2, n, 3))
    sum3 = sum(v[i] for i in range(3, n-1, 3))
    integral = 3/8 * h * (v[0] + 3*sum1 + 3*sum2 + 2*sum3 + v[n])
    return integral


dis1= MultiSimpson13(4,t1,t2)
dis2= MultiSimpson38(6,t1,t2)

print(dis1,dis2)

"""##Task 2
Use your previously implemented MultiSimpson13() and MultiSimpson38() function and write a general MultiSimpson() function that takes any n as parameter (n not necessarily a multiple of 2 or 3) and returns the integral result.
"""

def MultiSimpson(n, tmin, tmax):
    def ff(n):
      x=0
      y=n//3
      if(n%3!=0):
        x= (n- 3*y)
      return (x,y) 
    x,y=ff(n)
    print(x,y)
    result=0
    if(x!=0):
      result += MultiSimpson13(x, tmin, tmax)
    if(y != 0):
      result+= MultiSimpson38(y, tmin, tmax)
    
    return result


dis=MultiSimpson(10,t1,t2)
  
print(dis)